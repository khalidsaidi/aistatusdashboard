// Polyfill Web APIs for Node.js environment BEFORE imports
global.Request = class MockRequest {
  url: string;
  method: string;
  
  constructor(url: string, init?: RequestInit) {
    this.url = url;
    this.method = init?.method || 'GET';
  }
} as any;

global.URL = class MockURL {
  searchParams: URLSearchParams;
  
  constructor(url: string) {
    this.searchParams = new URLSearchParams(url.split('?')[1] || '');
  }
} as any;

// Mock AbortSignal.timeout for Node.js
if (!global.AbortSignal?.timeout) {
  global.AbortSignal = {
    timeout: (ms: number) => {
      const controller = new AbortController();
      setTimeout(() => controller.abort(), ms);
      return controller.signal;
    }
  } as any;
}

// Mock fetch for testing health endpoint
global.fetch = jest.fn();

// Now import after polyfills are set up
import { GET } from '@/app/api/health/route';
import { getCircuitBreakerStats } from '@/lib/status-fetcher';

// Mock the status fetcher
jest.mock('@/lib/status-fetcher', () => ({
  getCircuitBreakerStats: jest.fn(),
}));

describe('/api/health endpoint', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    // Reset process.memoryUsage mock
    const originalMemoryUsage = process.memoryUsage;
    process.memoryUsage = jest.fn(() => ({
      heapUsed: 50 * 1024 * 1024, // 50MB
      heapTotal: 100 * 1024 * 1024, // 100MB
      external: 10 * 1024 * 1024,
      arrayBuffers: 5 * 1024 * 1024,
      rss: 150 * 1024 * 1024,
    })) as any;
  });

  describe('Health Check Functionality', () => {
    it('should return healthy status when all systems are operational', async () => {
      // Mock successful database check
      (global.fetch as jest.MockedFunction<typeof fetch>)
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
        } as Response)
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          json: async () => ({
            providers: [
              { status: 'operational' },
              { status: 'operational' },
              { status: 'operational' },
            ]
          })
        } as Response);

      // Mock circuit breaker stats
      (getCircuitBreakerStats as jest.Mock).mockReturnValue([
        { providerId: 'openai', state: 'closed', failures: 0, lastFailure: null },
        { providerId: 'anthropic', state: 'closed', failures: 0, lastFailure: null },
      ]);

      const request = new Request('http://localhost:3000/api/health');
      const response = await GET(request);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.status).toBe('healthy');
      expect(data.checks.database.status).toBe('healthy');
      expect(data.checks.providers.status).toBe('healthy');
      expect(data.checks.circuitBreakers.status).toBe('healthy');
      expect(data.checks.memory.status).toBe('healthy');
    });

    it('should return degraded status when some systems have issues', async () => {
      // Mock successful database but degraded providers
      (global.fetch as jest.MockedFunction<typeof fetch>)
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
        } as Response)
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          json: async () => ({
            providers: [
              { status: 'operational' },
              { status: 'degraded' },
              { status: 'down' },
            ]
          })
        } as Response);

      // Mock some open circuit breakers
      (getCircuitBreakerStats as jest.Mock).mockReturnValue([
        { providerId: 'openai', state: 'closed', failures: 0, lastFailure: null },
        { providerId: 'anthropic', state: 'open', failures: 5, lastFailure: Date.now() },
      ]);

      const request = new Request('http://localhost:3000/api/health');
      const response = await GET(request);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data.status).toBe('degraded');
      expect(data.checks.providers.status).toBe('degraded'); // 1/3 operational < 80%
      expect(data.checks.circuitBreakers.status).toBe('degraded'); // Has open breakers
      expect(data.checks.circuitBreakers.openBreakers).toBe(1);
    });

    it('should return unhealthy status when critical systems fail', async () => {
      // Mock database failure
      (global.fetch as jest.MockedFunction<typeof fetch>)
        .mockRejectedValueOnce(new Error('Database connection failed'));

      const request = new Request('http://localhost:3000/api/health');
      const response = await GET(request);
      const data = await response.json();

      expect(response.status).toBe(503);
      expect(data.status).toBe('unhealthy');
      expect(data.checks.database.status).toBe('unhealthy');
      expect(data.checks.database.error).toContain('Database connection failed');
    });

    it('should measure database response time', async () => {
      // Mock slow database response
      (global.fetch as jest.MockedFunction<typeof fetch>)
        .mockImplementation(() => 
          new Promise(resolve => 
            setTimeout(() => resolve({
              ok: true,
              status: 200,
            } as Response), 100)
          )
        );

      const request = new Request('http://localhost:3000/api/health');
      const response = await GET(request);
      const data = await response.json();

      expect(data.checks.database.responseTime).toBeGreaterThan(50);
      expect(data.checks.database.responseTime).toBeLessThan(200);
    });

    it('should include system uptime and version info', async () => {
      // Mock successful responses
      (global.fetch as jest.MockedFunction<typeof fetch>)
        .mockResolvedValue({
          ok: true,
          status: 200,
          json: async () => ({ providers: [] })
        } as Response);

      (getCircuitBreakerStats as jest.Mock).mockReturnValue([]);

      const request = new Request('http://localhost:3000/api/health');
      const response = await GET(request);
      const data = await response.json();

      expect(data.uptime).toBeGreaterThan(0);
      expect(data.version).toBeDefined();
      expect(data.timestamp).toBeDefined();
      expect(() => new Date(data.timestamp)).not.toThrow();
    });

    it('should track memory usage correctly', async () => {
      // Mock high memory usage
      process.memoryUsage = jest.fn(() => ({
        heapUsed: 90 * 1024 * 1024, // 90MB
        heapTotal: 100 * 1024 * 1024, // 100MB
        external: 10 * 1024 * 1024,
        arrayBuffers: 5 * 1024 * 1024,
        rss: 150 * 1024 * 1024,
      })) as any;

      // Mock other successful responses
      (global.fetch as jest.MockedFunction<typeof fetch>)
        .mockResolvedValue({
          ok: true,
          status: 200,
          json: async () => ({ providers: [] })
        } as Response);

      (getCircuitBreakerStats as jest.Mock).mockReturnValue([]);

      const request = new Request('http://localhost:3000/api/health');
      const response = await GET(request);
      const data = await response.json();

      expect(data.checks.memory.percentage).toBe(90); // 90% memory usage
      expect(data.checks.memory.status).toBe('degraded'); // > 80%
    });
  });

  describe('Health Check Caching', () => {
    it('should cache health check results for 30 seconds', async () => {
      // Mock successful response
      (global.fetch as jest.MockedFunction<typeof fetch>)
        .mockResolvedValue({
          ok: true,
          status: 200,
          json: async () => ({ providers: [] })
        } as Response);

      (getCircuitBreakerStats as jest.Mock).mockReturnValue([]);

      // First request
      const request1 = new Request('http://localhost:3000/api/health');
      const response1 = await GET(request1);
      const data1 = await response1.json();

      // Second request immediately after
      const request2 = new Request('http://localhost:3000/api/health');
      const response2 = await GET(request2);
      const data2 = await response2.json();

      // Should return same timestamp (cached)
      expect(data1.timestamp).toBe(data2.timestamp);
    });

    it('should bypass cache when force=true', async () => {
      // Mock successful response
      (global.fetch as jest.MockedFunction<typeof fetch>)
        .mockResolvedValue({
          ok: true,
          status: 200,
          json: async () => ({ providers: [] })
        } as Response);

      (getCircuitBreakerStats as jest.Mock).mockReturnValue([]);

      // First request
      const request1 = new Request('http://localhost:3000/api/health');
      await GET(request1);

      // Wait a small amount
      await new Promise(resolve => setTimeout(resolve, 10));

      // Second request with force=true
      const request2 = new Request('http://localhost:3000/api/health?force=true');
      const response2 = await GET(request2);

      expect(response2.status).toBe(200);
      // Should have made new health check (not cached)
    });
  });

  describe('Error Handling', () => {
    it('should handle complete system failure gracefully', async () => {
      // Mock all systems failing
      (global.fetch as jest.MockedFunction<typeof fetch>)
        .mockRejectedValue(new Error('Complete system failure'));

      (getCircuitBreakerStats as jest.Mock).mockImplementation(() => {
        throw new Error('Circuit breaker stats failed');
      });

      process.memoryUsage = jest.fn().mockImplementation(() => {
        throw new Error('Memory check failed');
      }) as any;

      const request = new Request('http://localhost:3000/api/health');
      const response = await GET(request);
      const data = await response.json();

      expect(response.status).toBe(503);
      expect(data.status).toBe('unhealthy');
      expect(data.checks.database.status).toBe('unhealthy');
    });

    it('should provide detailed error information', async () => {
      // Mock specific database error
      (global.fetch as jest.MockedFunction<typeof fetch>)
        .mockRejectedValueOnce(new Error('Connection timeout'));

      const request = new Request('http://localhost:3000/api/health');
      const response = await GET(request);
      const data = await response.json();

      expect(data.checks.database.error).toBe('Connection timeout');
    });
  });

  describe('Provider Health Assessment', () => {
    it('should correctly assess provider health percentages', async () => {
      const testCases = [
        {
          providers: [
            { status: 'operational' },
            { status: 'operational' },
            { status: 'operational' },
            { status: 'operational' },
            { status: 'operational' },
          ],
          expectedStatus: 'healthy' // 100% operational
        },
        {
          providers: [
            { status: 'operational' },
            { status: 'operational' },
            { status: 'operational' },
            { status: 'operational' },
            { status: 'degraded' },
          ],
          expectedStatus: 'healthy' // 80% operational
        },
        {
          providers: [
            { status: 'operational' },
            { status: 'operational' },
            { status: 'degraded' },
            { status: 'degraded' },
            { status: 'down' },
          ],
          expectedStatus: 'degraded' // 40% operational
        },
        {
          providers: [
            { status: 'down' },
            { status: 'down' },
            { status: 'down' },
            { status: 'down' },
            { status: 'down' },
          ],
          expectedStatus: 'unhealthy' // 0% operational
        },
      ];

      for (const testCase of testCases) {
        jest.clearAllMocks();

        (global.fetch as jest.MockedFunction<typeof fetch>)
          .mockResolvedValueOnce({
            ok: true,
            status: 200,
          } as Response)
          .mockResolvedValueOnce({
            ok: true,
            status: 200,
            json: async () => ({ providers: testCase.providers })
          } as Response);

        (getCircuitBreakerStats as jest.Mock).mockReturnValue([]);

        const request = new Request('http://localhost:3000/api/health');
        const response = await GET(request);
        const data = await response.json();

        expect(data.checks.providers.status).toBe(testCase.expectedStatus);
      }
    });
  });
}); 